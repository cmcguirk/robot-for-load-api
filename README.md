# robot-for-load-api
Analyzes optimal robot to assign to a load within a 2D coordinate space

# Running and Testing the API
This is an ASP.NET Core 3.1 application.  You can open the RobotForLoadApi.sln in Visual Studio or open the RobotForLoadApi folder containing the .sln file in VS Code, which allows for Building the Solution and running it by either debugging or starting without debugging.  Alternatively, with the .NET Core 3.1 SDK installed, the "dotnet run" command can be used from the command line while in the RobotForLoadApi folder that contains the RobotForLoadApi.csproj file.  In order for appropriate API URLs to be used when running the app, your ASPNETCORE_ENVIRONMENT system environment variable must be set to "Development".

Automated tests can be run either with Visual Studio's Test Explorer or from the command line with the "dotnet test" command while in the RobotForLoadApi.Test folder.  In order to exercise the app while it is running, import the postman_collection.json file into the Postman app and send the RobotForLoad/FindBest request.  Depending on how you launched the API, you may have to modify the port number in the Postman request to match your local setup.

# Next Steps
The app uses http, but should a SSL certificate should be obtained that can be used when the app would be hosted and the app should be changed to use https.  The app has no access restrictions, it should likely have a system of authentication and authorization so it can only be accessed by specific parties.  The app should have a CICD pipeline for automated deployment.  The app should have error logging for things like connectivity to the robots API being down or undhandled exceptions.

If the direction the robot is facing has an appreciable effect on the performance that could be expected from assigning that robot to the input load, then it could be plausible to collect that data and include it in the robots API and then include it as a factor in calculating the optimal robot choice.  A calculation could be made using the position coordinates and the angle the robot is currently facing to determine how many degrees it needs to rotate, and number of degrees needed to rotate could probably be translated to time, and distance could probably be translated to time, and the times could be added together and then compared with other robots' times.  It may also be possible that some robots could be temporarily busy and unable to interact with a load until they complete another task.  If so, it could make sense to track either a status to just exclude the robots that are currently busy or track when the robots are expected to complete their remaining tasks as well as the position in which the robots are expected to be when they complete their last remaining task.  And then the analysis can use their future position and translate that distance into time and combine that time with the wait until completing the last remaining task and compare that quantity with other robots.  This might find robots that are currently doing tasks could still be the optimal choice if they're finishing soon enough and/or close enough to the requested load.
